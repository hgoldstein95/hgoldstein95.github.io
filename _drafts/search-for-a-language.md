---
layout: post
title: The Search for my Own Language
categories: misc
---

## Necessary Features
### Static Types
I wrote a blog post last week about
[Rust and Idris]({{ site.baseurl }}).
My basic goal was to explain why I prefer languages with powerful type systems
and compilers that catch your errors earlier. I like languages where the
statement "if it compiles, then it runs" is **almost always** true, and where
"if it compiles, then it's correct" is **often** true. Clearly, then, my
language will have to be statically typed.

### First-Class Functions
Once you get used to functional programming, it's really hard to let go of
first-class functions. There are a ton of really natural solutions to
programming problems that can be expressed in terms of higher-order functions
like `map` or `fold`. I think it would be silly for me to design a modern
language that doesn't support these kinds of solutions.

### Insignificant White-space

### Good Tooling

### Native Compilation

## Potential Features
### Modules

### Macros

### Algebraic Types

### Low-Level Primitives

### Foreign Function Interfaces

## Places to Innovate
### Type System

### Syntax
